
import EventEmitter from 'events'
import Sort from './sort'
import Links from './links'
import Filter from './filter'
import * as utils from '../../utils'

/**
 * Identifier for the order key in the query parameters generated by the state.
 * @type {string}
 */
const ORDER = 'order'

/**
 * Key to notify users of an error.
 * @type {string}
 * @see {State#notify}
 */
const NOTIFY_ERROR = 'error'

/**
 * Key to notify users of an informational message.
 * @type {string}
 * @see {State#notify}
 */
const NOTIFY_INFO = 'info'

/**
 * Key to notify users of a success.
 * @type {string}
 * @see {State#notify}
 */
const NOTIFY_SUCCESS = 'success'

/**
 * Encapsulate application state.
 *
 * Emits the following events:
 *  - `core.state.updated`: fired whenever the result set is updated.
 *  - `core.filter.updated`: fired whenever the search filter is updated.
 *  - `core.sort.updated`: fired whenever the sort is updated.
 *  - `core.links.updated`: fired whenever the links are updated.
 *  - `core.links.navigate`: fired to navigate to the specified data link.
 *
 * @class
 * @extends {EventEmitter}
 */
class State extends EventEmitter {
  /**
   * @constructor
   * @param {object} options Configuration options for this object.
   */
  constructor(options) {
    super()

    const config = Object.assign({
      sort: {
        allowMultiple: false
      }
    }, options)

    /**
     * The total number of results that match this request, ignoring any
     * paging parameters.
     * @member
     * @type {integer}
     */
    this.count = undefined

    /**
     * The active filter for the given result set.
     * @type {Filter}
     */
    this.filter = new Filter()

    /**
     * The related links for the given result set.
     * @type {Links}
     */
    this.links = new Links()

    /**
     * The active sort for the given result set.
     * @type {Sort}
     */
    this.sort = new Sort(config.sort.allowMultiple === true)

    /**
     * The result data for the current state.
     * @type {object}
     * @private
     */
    this._result = null

    // propagate any events fired on filter, sort, and links through this
    // event emitter - consumers don't have to know how this is implemented,
    // just have to listen to events on the state instance

    utils.events.propagate(this.filter, this)
    utils.events.propagate(this.sort, this)
    utils.events.propagate(this.links, this)

    this.on('core.filter.updated', () => { this.queryUpdated() })
    this.on('core.sort.updated', () => { this.queryUpdated() })
  }

  /**
   * @returns {object} The result data for this state.
   */
  get result() {
    return this._result
  }

  /**
   * Set the result data, and fire the state updated event.
   * @param {object} value The updated result value.
   */
  set result(value) {
    this._result = value
    this.updated()
  }

  /**
   * Return the filter data for the current state.
   * @returns {object} The filter values.
   * @see {Filter#get}
   */
  getFilter() {
    return this.filter.get() || {}
  }

  /**
   * Return the sort data for the current state.
   * @returns {array} The array of sort values, formatted as `field,direction`.
   * @see {Sort#get}
   */
  getSort() {
    return this.sort.get() || []
  }

  /**
   * Generate Sequelize-compatible query options based on the current state.
   * @returns {object} The query options object.
   */
  getQueryOptions() {
    return Object.assign({
      [ORDER]: this.getSort()
    }, this.getFilter())
  }

  /**
   * Load a response into the application state, and trigger the update event.
   * @param {object} response The response object to load.
   */
  loadResponse(response) {
    this._result = response.result
    this.count = response.total
    this.links.update(response._links)
    this.updated()
  }

  /**
   * Notify subscribers that the user should be shown a notification message.
   * @param {string} type The type of notification to show ('error', 'info',
   *  'success').
   * @param {string} message The message for the notification.
   * @param {array|object} details Additional details to show with the
   *  notification.
   * @emits core.state.notify Including the type and notification details.
   */
  notify(type, message, details) {
    const notification = { message, details }
    this.emit('core.state.notify', type, notification)
    this.emit(`core.state.notify.${type}`, notification)
  }

  /**
   * Notify subscribers of an informational message.
   * @param {string} message The informational message for the notification.
   * @param {...any} args Arguments to pass to notify.
   * @emits core.state.notify.info
   * @see {State#notify}
   */
  notifyInfo(message, ...args) {
    this.notify(NOTIFY_INFO, ...args)
  }

  /**
   * Notify subscribers of a success message.
   * @param {string} message The success message for the notification.
   * @param {...any} args Additional arguments to pass to notify.
   * @emits core.state.notify.success
   * @see {State#notify}
   */
  notifySuccess(message = 'Success!', ...args) {
    this.notify(NOTIFY_SUCCESS, message, ...args)
  }

  /**
   * Notify subscribers of an error message.
   * @param {string} message The error message for the notification.
   * @param {...any} args Additional arguments to pass to notify.
   * @emits core.state.notify.error
   * @see {State#notify}
   */
  notifyError(message = 'An error ocurred', ...args) {
    this.notify(NOTIFY_ERROR, message, ...args)
  }

  /**
   * Notify subscribers that the query has been updated.
   * @emits core.state.queryUpdated
   */
  queryUpdated() {
    this.emit('core.state.queryUpdated', this)
  }

  /**
   * Notify subscribers to refresh their result object.
   * @emits core.state.refresh
   */
  refresh() {
    this.emit('core.state.refresh', this)
  }

  /**
   * Generate a response object from the current state.
   * @returns {object} The generated response object.
   */
  toResponse() {
    if (!this.result) {
      return null
    }

    return {
      result: this.result,
      total: this.count,
      _links: this.links.get()
    }
  }

  /**
   * Notify subscribers that the application state has been updated.
   * @emits core.state.updated
   */
  updated() {
    this.emit('core.state.updated', this)
  }
}

export default State
export { ORDER, NOTIFY_INFO, NOTIFY_SUCCESS, NOTIFY_ERROR }
