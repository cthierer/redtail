/**
 * @module redtail/modules/core/middleware/handleError
 */

/**
 * Build an response object from an error object. The response object includes:
 *  - message: a human-readable description of the error
 *  - code: a unique code describing the error
 *  - value: the value that caused the error (for validation failures)
 *  - field: the field that caused the erorr (for validation failures)
 *  - request_id: the ID for this request (for log tracing)
 *
 * The function will format errors generated by the application and by
 * Sequelize.
 *
 * @param {object} fromObj The error object to build the response object from.
 * @param {string} requestId The request ID value to set.
 * @returns {object} The generated object.
 * @todo Standardize this data structure.
 */
function buildError(fromObj, requestId) {
  return {
    message: fromObj.message,
    code: fromObj.code || fromObj.type,
    value: fromObj.value,
    field: fromObj.field || fromObj.path,
    request_id: requestId
  }
}

/**
 * Format an error object to return in a response.
 * @param {object} error The error object to format.
 * @param {string} requestId The request ID to attach to this error.
 * @returns {array} The formatted error response, contianing one or more errors
 *  generated from the error object.
 */
function formatError(error, requestId) {
  if (Array.isArray(error)) {
    return error.map(e => Object.assign({}, buildError(e, requestId)))
  }

  return [buildError(error, requestId)]
}

/**
 * Handle an error by logging it, setting the appropriate status code, and
 * returning a sanitized error response.
 *
 * The status code will be set from request context status code, if that
 * status code has been _manually_ set, and if that status code is a request
 * error (400-class error). Otherwise, the status code will be a 500 error,
 * indicating a server error.
 *
 * The body of the response will be an array of an error objects including an
 * error code, message, and value (if this is a validation error), pulled from
 * the `err` parameter.
 *
 * @returns {function} Middleware function.
 */
function handleError() {
  return (err, req, res, next) => {
    const logger = req.ctx.logger.child({ middleware: 'handleError' })
    const status = req.ctx.status
    const message = Array.isArray(err) ? err.map(error => error.message).join() : err.message
    const send = error => res.send(formatError(error, req.ctx.requestId))

    if (status && status >= 400 && status < 500) {
      // status already set by middleware to be a request error
      if (logger.info()) {
        logger.info({ err }, 'encountered a bad request: %s', message)
      }

      res.status(status)
      send(err)
    } else if (err && err.name && err.name === 'SequelizeValidationError') {
      // error is a validation error
      if (logger.info()) {
        logger.info({ err }, 'encountered a validation error: %s', message)
      }

      res.status(400)
      send(err.errors) // contains an array of validation failures
    } else {
      // unexpected error
      if (logger.error()) {
        logger.error({ err }, 'encountered an unexpected error: %s', message)
      }

      res.status(500)
      send(err)
    }

    next()
  }
}

export default handleError
